{"version":3,"file":"vue-word-highlighter.esm.js","sources":["../src/utils/getRowWordList.ts","../src/utils/createHighlightWordChunk.ts","../src/utils/extractDefaultSlotsText.ts","../src/utils/extractMatchesStrings.ts","../src/components/index.ts"],"sourcesContent":["export const getRowWordList = (\n  word: string,\n  splittedWordList: string[],\n): string[] => {\n  const rowWordList: string[] = [];\n  splittedWordList.forEach((splittedWord) => {\n    const start = rowWordList.join(\"\").length;\n    const end = start + splittedWord.length;\n    rowWordList.push(word.slice(start, end));\n  });\n\n  return rowWordList;\n};\n","import { h } from \"vue-demi\";\nimport diacritics from \"diacritics\";\nimport { getRowWordList } from \"./getRowWordList\";\n\nexport type MatchMode = \"exact\" | \"partial\";\ntype HighlightOptions = {\n  query: string | RegExp;\n  splitBySpace: boolean;\n  caseSensitive: boolean;\n  diacriticsSensitive: boolean;\n  matchMode: MatchMode;\n  highlightTag: string;\n  highlightClass: Record<string, boolean> | string | string[];\n  highlightStyle: Record<string, boolean> | string | string[];\n};\n\nconst escapeRegExp = (text: string) => {\n  return text.replace(/[-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n};\nconst getWordTransformerForRegExp = (matchMode: MatchMode) => {\n  if (matchMode === \"partial\") {\n    return (word: string) => escapeRegExp(word);\n  } else {\n    const STARTING_DELIMETERS = String.raw`[\\s/(\\[{<'\"|（『「\\u3000]`;\n    const ENDING_DELIMETERS = String.raw`[.,\\s/)\\]}>:;'\"!?|）』」。、\\u3000]`;\n    return (word: string) => {\n      return String.raw`(?<=^|${STARTING_DELIMETERS})${escapeRegExp(word)}(?=$|${ENDING_DELIMETERS})`;\n    };\n  }\n};\n\nconst createHighlightPattern = (options: {\n  query: string | RegExp;\n  splitBySpace: boolean;\n  caseSensitive: boolean;\n  matchMode: \"exact\" | \"partial\";\n}): RegExp => {\n  let pattern: string;\n\n  if (options.query instanceof RegExp) {\n    return new RegExp(\n      String.raw`(${options.query.source})`,\n      `g${options.caseSensitive ? \"\" : \"i\"}`,\n    );\n  }\n\n  const wordTransformerForRegExp = getWordTransformerForRegExp(\n    options.matchMode,\n  );\n\n  if (options.splitBySpace) {\n    const normalizeQuery = options.query.trim().replace(/\\s+/g, \" \");\n    pattern = String.raw`(${normalizeQuery\n      .split(/\\s/)\n      .map(wordTransformerForRegExp)\n      .join(\"|\")})`;\n  } else {\n    pattern = String.raw`(${wordTransformerForRegExp(options.query)})`;\n  }\n\n  return new RegExp(\n    String.raw`${pattern}`,\n    `g${options.caseSensitive ? \"\" : \"i\"}`,\n  );\n};\n\nexport const createHighlightWordChunk = (\n  targetText: string,\n  options: HighlightOptions,\n  isHtml = false,\n) => {\n  if (\n    !options.query ||\n    (options.query instanceof String && !options.query.trim())\n  ) {\n    return targetText;\n  }\n\n  let innerTargetText = targetText;\n  let innerQuery = options.query;\n  let hasDiacritics = false;\n\n  if (!options.diacriticsSensitive) {\n    innerTargetText = diacritics.remove(innerTargetText);\n    innerQuery =\n      options.query instanceof RegExp\n        ? new RegExp(diacritics.remove(options.query.source))\n        : diacritics.remove(options.query);\n    hasDiacritics = innerTargetText !== targetText;\n  }\n\n  const pattern = createHighlightPattern({\n    query: innerQuery,\n    splitBySpace: options.splitBySpace,\n    caseSensitive: options.caseSensitive,\n    matchMode: options.matchMode,\n  });\n\n  const wordList = innerTargetText.split(pattern);\n\n  // Make a list restoring the original string because diacritics may have been converted\n  const restoredWordList = hasDiacritics\n    ? getRowWordList(targetText, wordList)\n    : wordList;\n\n  if (isHtml) {\n    return wordList\n      .map((w: string, i: number) => {\n        if (pattern.test(w)) {\n          // FIXME: highlightClass and highlightStyle are only supported as string\n          const classLiteral = options.highlightClass\n            ? ` class=\"${options.highlightClass}\"`\n            : \"\";\n          const styleLiteral = options.highlightStyle\n            ? ` style=\"${options.highlightStyle}\"`\n            : \"\";\n          return `<${options.highlightTag}${classLiteral}${styleLiteral}>${restoredWordList[i]}</${options.highlightTag}>`;\n        }\n        return restoredWordList[i];\n      })\n      .join(\"\");\n  } else {\n    return wordList.map((w: string, i: number) => {\n      if (pattern.test(w)) {\n        return h(\n          options.highlightTag,\n          {\n            class: options.highlightClass,\n            style: options.highlightStyle,\n          },\n          restoredWordList[i],\n        );\n      }\n      return restoredWordList[i];\n    });\n  }\n};\n","import { isVue3 } from \"vue-demi\";\n\ntype SlotItem = { children: string | SlotItem[]; text: string };\ntype Slots = { default?: () => SlotItem[] };\n\nconst getSlotText = (slot: SlotItem): string => {\n  if (!Array.isArray(slot.children)) {\n    return slot.children ?? \"\";\n  }\n  return slot.children.map(getSlotText).join(\"\");\n};\n\nexport const extractDefaultSlotsText = (slots?: Slots): string => {\n  if (slots && slots.default) {\n    const defaultSlot = slots.default();\n    let slotText;\n    if (isVue3) {\n      slotText = getSlotText(defaultSlot[0]);\n    } else {\n      // vue 2 slots text is in vnode's text attribute\n      slotText = defaultSlot[0].text;\n    }\n    if (typeof slotText === \"string\") {\n      return slotText;\n    } else {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn(\"Slots should be text only\");\n      }\n      return \"\";\n    }\n  }\n  return \"\";\n};\n","import { isVue3 } from \"vue-demi\";\n\nexport const extractMatchesStrings = (\n  wordChunk: string | (string | unknown)[],\n): string[] => {\n  if (typeof wordChunk === \"string\") {\n    return [];\n  }\n  return wordChunk\n    .filter((w) => typeof w !== \"string\")\n    .map((v) => {\n      if (typeof v === \"string\") {\n        return v;\n      }\n      if (isVue3) {\n        return (v as { children: string }).children;\n      }\n      return (v as { children: { text: string }[] }).children[0].text;\n    });\n};\n","import {\n  defineComponent,\n  h,\n  install,\n  PropType,\n  isVue3,\n  VNode,\n  Comment,\n} from \"vue-demi\";\nimport {\n  createHighlightWordChunk,\n  MatchMode,\n} from \"../utils/createHighlightWordChunk\";\nimport { extractDefaultSlotsText } from \"../utils/extractDefaultSlotsText\";\nimport { extractMatchesStrings } from \"../utils/extractMatchesStrings\";\n\ninstall();\n\nexport default defineComponent({\n  name: \"VueWordHighlighter\",\n  props: {\n    query: {\n      type: [String, RegExp],\n      required: true,\n      default: \"\",\n    },\n    caseSensitive: {\n      type: Boolean,\n      default: false,\n    },\n    diacriticsSensitive: {\n      type: Boolean,\n      default: false,\n    },\n    splitBySpace: {\n      type: Boolean,\n      default: false,\n    },\n    matchMode: {\n      type: String as PropType<MatchMode>,\n      default: \"partial\",\n    },\n    highlightClass: {\n      type: [Object, String, Array] as PropType<\n        Record<string, boolean> | string | string[]\n      >,\n      default: \"\",\n    },\n    highlightStyle: {\n      type: [Object, String, Array] as PropType<\n        Record<string, boolean> | string | string[]\n      >,\n      default: \"\",\n    },\n    highlightTag: {\n      type: String,\n      default: \"mark\",\n    },\n    wrapperTag: {\n      type: String,\n      default: \"span\",\n    },\n    wrapperClass: {\n      type: [Object, String, Array],\n      default: \"\",\n    },\n    textToHighlight: {\n      type: String,\n      default: \"\",\n    },\n    htmlToHighlight: {\n      type: String,\n      default: \"\",\n    },\n  },\n  emits: [\"matches\"],\n  setup(props, ctx) {\n    return () => {\n      // --------------------------\n      // highlight html\n      // --------------------------\n      // preferred htmlToHighlight if provided\n      if (props.htmlToHighlight) {\n        if (!isVue3) {\n          throw new Error(\"htmlToHighlight prop is only supported in Vue 3\");\n        }\n        const HTML_TAG_PATTERN = `(<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)`;\n        const words: string[] = props.htmlToHighlight.split(\n          new RegExp(HTML_TAG_PATTERN, \"gs\"),\n        );\n        const highlightedHtml = words\n          .map((word, i) => {\n            // Skip if the word is inside a script tag\n            if (new RegExp(HTML_TAG_PATTERN).test(word)) {\n              return word;\n            }\n            // Skip if the word is inside a script tag\n            if (i > 0 && words[i - 1].startsWith(\"<script\")) {\n              return word;\n            }\n\n            return createHighlightWordChunk(\n              word,\n              {\n                query: props.query,\n                splitBySpace: props.splitBySpace,\n                caseSensitive: props.caseSensitive,\n                diacriticsSensitive: props.diacriticsSensitive,\n                matchMode: props.matchMode,\n                highlightTag: props.highlightTag,\n                highlightClass: props.highlightClass,\n                highlightStyle: props.highlightStyle,\n              },\n              true,\n            );\n          })\n          .join(\"\");\n\n        return h(props.wrapperTag, {\n          class: props.wrapperClass,\n          innerHTML: highlightedHtml,\n        });\n      }\n\n      // --------------------------\n      // highlight props text\n      // --------------------------\n      if (props.textToHighlight) {\n        const highlightWordChunk = createHighlightWordChunk(\n          props.textToHighlight,\n          {\n            query: props.query,\n            splitBySpace: props.splitBySpace,\n            caseSensitive: props.caseSensitive,\n            diacriticsSensitive: props.diacriticsSensitive,\n            matchMode: props.matchMode,\n            highlightTag: props.highlightTag,\n            highlightClass: props.highlightClass,\n            highlightStyle: props.highlightStyle,\n          },\n        );\n\n        ctx.emit(\"matches\", extractMatchesStrings(highlightWordChunk));\n\n        return h(\n          props.wrapperTag,\n          {\n            class: props.wrapperClass,\n          },\n          highlightWordChunk,\n        );\n      }\n\n      // --------------------------\n      // highlight slots\n      // --------------------------\n      // TODO: refactor this\n      if (isVue3) {\n        // only supported nested slots in Vue 3\n        if (ctx.slots && ctx.slots.default) {\n          const createHighlightedNode = (node: VNode): VNode => {\n            if (node.type === Comment) {\n              return node;\n            }\n            if (typeof node.children === \"string\") {\n              const highlightWordChunk = createHighlightWordChunk(\n                node.children,\n                {\n                  query: props.query,\n                  splitBySpace: props.splitBySpace,\n                  caseSensitive: props.caseSensitive,\n                  diacriticsSensitive: props.diacriticsSensitive,\n                  matchMode: props.matchMode,\n                  highlightTag: props.highlightTag,\n                  highlightClass: props.highlightClass,\n                  highlightStyle: props.highlightStyle,\n                },\n              );\n\n              const matchesStrings = extractMatchesStrings(highlightWordChunk);\n              ctx.emit(\"matches\", matchesStrings);\n\n              if (matchesStrings.length === 0) {\n                return node;\n              }\n              // if node is not a string, it's a html tag\n              if (typeof node.type == \"string\") {\n                return h(\n                  node.type,\n                  {\n                    ...node.props,\n                  },\n                  [\n                    h(\n                      props.wrapperTag,\n                      {\n                        class: props.wrapperClass,\n                      },\n                      highlightWordChunk,\n                    ),\n                  ],\n                );\n              } else {\n                return h(\n                  props.wrapperTag,\n                  {\n                    class: props.wrapperClass,\n                  },\n                  highlightWordChunk,\n                );\n              }\n            } else {\n              return h(\n                node.type as string,\n                {\n                  ...node.props,\n                },\n                Array.isArray(node.children)\n                  ? (node.children as VNode[]).map((c: VNode) =>\n                      createHighlightedNode(c),\n                    )\n                  : [],\n              );\n            }\n          };\n          const nodes = ctx.slots.default();\n          return Array.isArray(nodes)\n            ? nodes.map((n: VNode) => createHighlightedNode(n))\n            : nodes;\n        }\n      } else {\n        // not support nested slots in Vue 2\n        const targetText = extractDefaultSlotsText(ctx.slots);\n\n        const highlightWordChunk = createHighlightWordChunk(targetText, {\n          query: props.query,\n          splitBySpace: props.splitBySpace,\n          caseSensitive: props.caseSensitive,\n          diacriticsSensitive: props.diacriticsSensitive,\n          matchMode: props.matchMode,\n          highlightTag: props.highlightTag,\n          highlightClass: props.highlightClass,\n          highlightStyle: props.highlightStyle,\n        });\n\n        ctx.emit(\"matches\", extractMatchesStrings(highlightWordChunk));\n\n        return h(\n          props.wrapperTag,\n          {\n            class: props.wrapperClass,\n          },\n          highlightWordChunk,\n        );\n      }\n    };\n  },\n});\n"],"names":["h","isVue3","install","defineComponent","Comment","diacritics","escapeRegExp","text","replace","createHighlightPattern","options","pattern","query","RegExp","String","raw","source","caseSensitive","wordTransformerForRegExp","matchMode","word","STARTING_DELIMETERS","ENDING_DELIMETERS","getWordTransformerForRegExp","splitBySpace","normalizeQuery","trim","split","map","join","createHighlightWordChunk","targetText","isHtml","innerTargetText","innerQuery","hasDiacritics","diacriticsSensitive","remove","wordList","restoredWordList","splittedWordList","rowWordList","forEach","splittedWord","start","length","end","push","slice","getRowWordList","w","i","test","classLiteral","highlightClass","styleLiteral","highlightStyle","highlightTag","class","style","getSlotText","slot","Array","isArray","children","extractMatchesStrings","wordChunk","filter","v","VueWordHighlighter","name","props","type","required","default","Boolean","Object","wrapperTag","wrapperClass","textToHighlight","htmlToHighlight","emits","setup","ctx","Error","HTML_TAG_PATTERN","words","highlightedHtml","startsWith","innerHTML","highlightWordChunk","emit","slots","defaultSlot","slotText","process","env","NODE_ENV","console","warn","extractDefaultSlotsText","createHighlightedNode","node","matchesStrings","c","nodes","n"],"mappings":"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"}